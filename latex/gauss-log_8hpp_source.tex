\hypertarget{gauss-log_8hpp_source}{}\doxysection{gauss-\/log.hpp}
\label{gauss-log_8hpp_source}\index{src/SingGQ/gauss-\/log.hpp@{src/SingGQ/gauss-\/log.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#include <SingGQ/gauss-\/rule.hpp>}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <SingGQ/gauss-\/jacobi.hpp>}}
\DoxyCodeLine{4 }
\DoxyCodeLine{5 }
\DoxyCodeLine{6 \textcolor{keyword}{namespace }GQLog\{}
\DoxyCodeLine{7 }
\DoxyCodeLine{16     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{17     \textcolor{keyword}{class }\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule}{GaussLogRule}} : \textcolor{keyword}{public} \mbox{\hyperlink{class_gauss_rule}{GaussRule}}<T>\{}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20         \textcolor{keyword}{protected}:}
\DoxyCodeLine{21 }
\DoxyCodeLine{27         std::vector<T> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad490796c3547284bf80d576edfdf24df}{nodes}};}
\DoxyCodeLine{28         std::vector<T> weights;}
\DoxyCodeLine{29         std::size\_t degree;}
\DoxyCodeLine{30 }
\DoxyCodeLine{31         \textcolor{keyword}{public}:}
\DoxyCodeLine{37         std::size\_t \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad3d49217931c0b3837f81e634664fbb4}{getDeg}}()\textcolor{keyword}{ const}\{}
\DoxyCodeLine{38             \textcolor{keywordflow}{return} this-\/>degree;}
\DoxyCodeLine{39         \}}
\DoxyCodeLine{40 }
\DoxyCodeLine{46         std::vector<T> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a081652c886e48757da8523cd8171d17c}{getN}}()\textcolor{keyword}{ const}\{}
\DoxyCodeLine{47             \textcolor{keywordflow}{return} this-\/>\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad490796c3547284bf80d576edfdf24df}{nodes}};}
\DoxyCodeLine{48         \}}
\DoxyCodeLine{49 }
\DoxyCodeLine{55         std::vector<T> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_aab0c88d897fded81319597bdd98b165a}{getW}}()\textcolor{keyword}{ const}\{}
\DoxyCodeLine{56             \textcolor{keywordflow}{return} this-\/>weights;}
\DoxyCodeLine{57         \}}
\DoxyCodeLine{58 }
\DoxyCodeLine{63         \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_af9a9416ef01cbbd68855fe93c96e7eba}{GaussLogRule}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{64 }
\DoxyCodeLine{71         \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a7ccc956f269ef39118bb36e20adba162}{GaussLogRule}}(\textcolor{keyword}{const} \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule}{GaussLogRule}}\& gql)\{}
\DoxyCodeLine{72             this-\/>degree = gql.\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad3d49217931c0b3837f81e634664fbb4}{getDeg}}();}
\DoxyCodeLine{73             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < degree; i++)\{}
\DoxyCodeLine{74                 this-\/>nodes.push\_back(gql.\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a081652c886e48757da8523cd8171d17c}{getN}}()[i]);}
\DoxyCodeLine{75                 this-\/>weights.push\_back(gql.\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_aab0c88d897fded81319597bdd98b165a}{getW}}()[i]);}
\DoxyCodeLine{76             \}}
\DoxyCodeLine{77         \}}
\DoxyCodeLine{78         }
\DoxyCodeLine{84         \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a676217fd4537976917735e8f58be61c6}{GaussLogRule}}(std::size\_t n) \{}
\DoxyCodeLine{85             this-\/>degree = n;}
\DoxyCodeLine{86 }
\DoxyCodeLine{87             \textcolor{comment}{// Computing the nodes}}
\DoxyCodeLine{88             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> nws = \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_affa69ff49dacba72e627338a63518874}{nw}}(n);}
\DoxyCodeLine{89 }
\DoxyCodeLine{90             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; i++)\{}
\DoxyCodeLine{91                 \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad490796c3547284bf80d576edfdf24df}{nodes}}.push\_back(nws.col(0)[i]);}
\DoxyCodeLine{92                 weights.push\_back(nws.col(1)[i]);}
\DoxyCodeLine{93             \}}
\DoxyCodeLine{94         \}}
\DoxyCodeLine{95         }
\DoxyCodeLine{96 }
\DoxyCodeLine{106         \textcolor{keyword}{template}<\textcolor{keyword}{typename} F>}
\DoxyCodeLine{107         T \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a2c8ccdb5a87d44db5efa8a9096473559}{operator()}}(F f) \{}
\DoxyCodeLine{108             T quad = 0;}
\DoxyCodeLine{109             }
\DoxyCodeLine{110             \textcolor{comment}{// evaluation of integral over ]0,1[, no singularity => use GaussLegendreRule}}
\DoxyCodeLine{111             \mbox{\hyperlink{class_g_q_jacobi_1_1_gauss_legendre_rule}{GQJacobi::GaussLegendreRule<T>}} glg(this-\/>degree);}
\DoxyCodeLine{112             quad += glg([\&](T x)\{ \textcolor{keywordflow}{return} log(x+1)*f(x); \}, 0, 1);}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 }
\DoxyCodeLine{115             \textcolor{comment}{// evaluation of integral over ]-\/1,0[}}
\DoxyCodeLine{116             \textcolor{keywordflow}{for}(std::size\_t i = 0; i < degree; i++)\{}
\DoxyCodeLine{117                 \textcolor{comment}{// cast to real for cmath functions. Is only meant for f:R-\/>R anyways}}
\DoxyCodeLine{118                 quad -\/= (weights[i] * std::real(f(\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad490796c3547284bf80d576edfdf24df}{nodes}}[i]-\/1))) ; }
\DoxyCodeLine{119             \} }
\DoxyCodeLine{120             \textcolor{keywordflow}{return} quad;}
\DoxyCodeLine{121         \}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123 }
\DoxyCodeLine{134         \textcolor{keyword}{template}<\textcolor{keyword}{typename} F>}
\DoxyCodeLine{135         T \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a095301b81279ab460f27bbb5dfe20855}{operator()}}(F f, T a, T b) \{}
\DoxyCodeLine{136             assert(a < b);}
\DoxyCodeLine{137             \textcolor{comment}{// Impossible case}}
\DoxyCodeLine{138             assert(a >= -\/1);}
\DoxyCodeLine{139 }
\DoxyCodeLine{140             \textcolor{keywordflow}{if}(a==-\/1)\{}
\DoxyCodeLine{141                 }
\DoxyCodeLine{142             \}}
\DoxyCodeLine{143             T quad = 0;}
\DoxyCodeLine{144             }
\DoxyCodeLine{145             \textcolor{comment}{// evaluation of integral over ]0,1[, no singularity => use GaussLegendreRule}}
\DoxyCodeLine{146             \mbox{\hyperlink{class_g_q_jacobi_1_1_gauss_legendre_rule}{GQJacobi::GaussLegendreRule<T>}} glg(this-\/>degree);}
\DoxyCodeLine{147             quad += glg([\&](T x)\{ \textcolor{keywordflow}{return} log(x+1)*f(x); \}, 0, 1);}
\DoxyCodeLine{148 }
\DoxyCodeLine{149 }
\DoxyCodeLine{150             \textcolor{comment}{// evaluation of integral over ]-\/1,0[}}
\DoxyCodeLine{151             \textcolor{keywordflow}{for}(std::size\_t i = 0; i < degree; i++)\{}
\DoxyCodeLine{152                 \textcolor{comment}{// cast to real for cmath functions. Is only meant for f:R-\/>R anyways}}
\DoxyCodeLine{153                 quad -\/= (weights[i] * std::real(f(\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad490796c3547284bf80d576edfdf24df}{nodes}}[i]-\/1))) ; }
\DoxyCodeLine{154             \} }
\DoxyCodeLine{155             \textcolor{keywordflow}{return} quad;}
\DoxyCodeLine{156         \}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158 }
\DoxyCodeLine{159 }
\DoxyCodeLine{166         \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule}{GaussLogRule}}\& \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a8ca605b9741914d79d1270be62e8cb58}{operator=}}(\textcolor{keyword}{const} \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule}{GaussLogRule}}\& glq)\{}
\DoxyCodeLine{167             \textcolor{keywordflow}{if}(\textcolor{keyword}{this} != \&glq)\{}
\DoxyCodeLine{168                 this-\/>degree = glq.\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad3d49217931c0b3837f81e634664fbb4}{getDeg}}();}
\DoxyCodeLine{169 }
\DoxyCodeLine{170                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < this-\/>degree; i++)\{}
\DoxyCodeLine{171                     this-\/>nodes.push\_back(glq.\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a081652c886e48757da8523cd8171d17c}{getN}}()[i]);}
\DoxyCodeLine{172                     this-\/>weights.push\_back(glq.\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_aab0c88d897fded81319597bdd98b165a}{getW}}()[i]);}
\DoxyCodeLine{173                 \}}
\DoxyCodeLine{174             \}}
\DoxyCodeLine{175             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{176         \}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 }
\DoxyCodeLine{179         \textcolor{keyword}{protected}:}
\DoxyCodeLine{187         Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_aaf87fe6ff783c2ae5a5971ee7bcd0301}{shifted\_c\_log}}(std::size\_t n)\{}
\DoxyCodeLine{188             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> abj = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero(n,2);}
\DoxyCodeLine{189 }
\DoxyCodeLine{190             \textcolor{comment}{// Computing the regular recurrence relation coefficients}}
\DoxyCodeLine{191             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> ab = this-\/>\mbox{\hyperlink{class_gauss_rule_aebc3bf05fac716fefa21dfd167ae8ab2}{c\_jacobi}}(n, 0, 0);}
\DoxyCodeLine{192             }
\DoxyCodeLine{193             \textcolor{comment}{// Applying W. Gautschi's method}}
\DoxyCodeLine{194             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; i++)\{}
\DoxyCodeLine{195                 abj(i,0) = (1+ab(i,0))/2.;}
\DoxyCodeLine{196             \}}
\DoxyCodeLine{197             abj(0, 1) = ab(0,1)/2.;}
\DoxyCodeLine{198             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 1; i < n; i++)\{}
\DoxyCodeLine{199                 abj(i,1) = ab(i,1)/4.;}
\DoxyCodeLine{200             \}}
\DoxyCodeLine{201             \textcolor{keywordflow}{return} abj;}
\DoxyCodeLine{202         \}}
\DoxyCodeLine{203 }
\DoxyCodeLine{211         Eigen::Vector<T, Eigen::Dynamic> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a4e3a40c4699e00db8e819deb46d05dd8}{mmom\_log}}(std::size\_t n)\{}
\DoxyCodeLine{212             Eigen::Vector<T, Eigen::Dynamic> mm = Eigen::Vector<T, Eigen::Dynamic>::Zero(n);}
\DoxyCodeLine{213             \textcolor{keywordtype}{double} c = 1.0;}
\DoxyCodeLine{214 }
\DoxyCodeLine{215             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; i++)\{}
\DoxyCodeLine{216                 \textcolor{keywordflow}{if}(i == 0)\{}
\DoxyCodeLine{217                     mm[0] = 1;}
\DoxyCodeLine{218                 \}}
\DoxyCodeLine{219                 \textcolor{keywordflow}{else}\{}
\DoxyCodeLine{220                     \textcolor{keywordtype}{double} p = (i+1)*i;}
\DoxyCodeLine{221                     mm[i] = (pow(-\/1, i)/p)*(pow(tgamma(1), 2));}
\DoxyCodeLine{222                 \}}
\DoxyCodeLine{223                 mm[i] *=c;}
\DoxyCodeLine{224                 c *= (0.5*(i+1)/(2*(i+1)-\/1));}
\DoxyCodeLine{225             \}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227             \textcolor{keywordflow}{return} mm;}
\DoxyCodeLine{228         \}}
\DoxyCodeLine{229 }
\DoxyCodeLine{240         Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a366d8f634fc624b92e77c733d5068748}{chebyshev}}(std::size\_t n,Eigen::Vector<T, Eigen::Dynamic> mom, Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> abj)\{}
\DoxyCodeLine{241             \textcolor{comment}{// size check}}
\DoxyCodeLine{242             assert(2*n == mom.rows());}
\DoxyCodeLine{243             assert(2*n == abj.rows());}
\DoxyCodeLine{244 }
\DoxyCodeLine{245             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> ab = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero(n,2);}
\DoxyCodeLine{246 }
\DoxyCodeLine{247             ab(0,0) = abj(0,0) + (mom[1]/mom[0]);}
\DoxyCodeLine{248             ab(0,1) = mom[0];}
\DoxyCodeLine{249 }
\DoxyCodeLine{250             T s\_1 = 0.;}
\DoxyCodeLine{251             }
\DoxyCodeLine{252             \textcolor{comment}{// Computing sigma-\/matrix}}
\DoxyCodeLine{253             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> sigma = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero(n+1, 2*n);}
\DoxyCodeLine{254 }
\DoxyCodeLine{255             \textcolor{comment}{// Initializing first row}}
\DoxyCodeLine{256             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} l = 0; l < 2*n; l++)\{}
\DoxyCodeLine{257                 sigma(0, l) = mom[l];}
\DoxyCodeLine{258             \}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260             \textcolor{comment}{// Filling in n following rows}}
\DoxyCodeLine{261             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} k = 1; k < n; k++)\{}
\DoxyCodeLine{262                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} l = k; l < 2*n-\/k; l++)\{}
\DoxyCodeLine{263                     \textcolor{keywordflow}{if}(k > 1)\{ s\_1 = sigma(k-\/2, l); \}}
\DoxyCodeLine{264                     sigma(k,l) = sigma(k-\/1,l+1) -\/ (ab(k-\/1,0) -\/ abj(l,0))*sigma(k-\/1,l)-\/ab(k-\/1,1)*s\_1 + abj(l,1)*sigma(k-\/1,l-\/1);}
\DoxyCodeLine{265 }
\DoxyCodeLine{266                 \}}
\DoxyCodeLine{267                 \textcolor{comment}{// alpha\_k}}
\DoxyCodeLine{268                 ab(k, 0) = abj(k, 0)+ (sigma(k,k+1)/sigma(k,k)) -\/ (sigma(k-\/1,k)/sigma(k-\/1,k-\/1));}
\DoxyCodeLine{269 }
\DoxyCodeLine{270                 \textcolor{comment}{// beta\_k}}
\DoxyCodeLine{271                 ab(k, 1) = sigma(k,k)/sigma(k-\/1,k-\/1);}
\DoxyCodeLine{272             \}}
\DoxyCodeLine{273             \textcolor{keywordflow}{return} ab;}
\DoxyCodeLine{274         \}}
\DoxyCodeLine{275 }
\DoxyCodeLine{281         Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_affa69ff49dacba72e627338a63518874}{nw}}(std::size\_t n) \{}
\DoxyCodeLine{282 }
\DoxyCodeLine{283             \textcolor{comment}{// Finding the coefficients}}
\DoxyCodeLine{284             \textcolor{keywordtype}{double} gamma\_0 = 1; \textcolor{comment}{// given that a=b=0}}
\DoxyCodeLine{285             Eigen::Vector<T, Eigen::Dynamic> mom = \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a4e3a40c4699e00db8e819deb46d05dd8}{mmom\_log}}(2*n);}
\DoxyCodeLine{286             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> abm = \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_aaf87fe6ff783c2ae5a5971ee7bcd0301}{shifted\_c\_log}}(2*n);}
\DoxyCodeLine{287             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> ab = \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_a366d8f634fc624b92e77c733d5068748}{chebyshev}}(n, mom, abm);}
\DoxyCodeLine{288             }
\DoxyCodeLine{289 }
\DoxyCodeLine{290             \textcolor{comment}{// Solving for the coefficients with Golub-\/Welsch}}
\DoxyCodeLine{291             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> J\_n = this-\/>\mbox{\hyperlink{class_gauss_rule_a16155f5ed140bcb5071c62535cf16ccc}{tridiagCoeffs}}(ab, n);}
\DoxyCodeLine{292            }
\DoxyCodeLine{293             \textcolor{comment}{// The self-\/adjoint solver. Significant speedup for large n}}
\DoxyCodeLine{294             Eigen::SelfAdjointEigenSolver<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>> solve(J\_n); \textcolor{comment}{// yields much faster computations of high n}}
\DoxyCodeLine{295 }
\DoxyCodeLine{296             \textcolor{comment}{/* Extracting eigenvalues and vectors. Only the real part is considered as }}
\DoxyCodeLine{297 \textcolor{comment}{             * they are guaranteed to be real given the nature of the problem */}}
\DoxyCodeLine{298             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> eigenvecs = solve.eigenvectors().real();}
\DoxyCodeLine{299             Eigen::Vector<T, Eigen::Dynamic> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad490796c3547284bf80d576edfdf24df}{nodes}}= solve.eigenvalues().real();}
\DoxyCodeLine{300 }
\DoxyCodeLine{301             \textcolor{comment}{// Solving the weights using Golub-\/Welsch algorithm formula }}
\DoxyCodeLine{302             Eigen::Vector<T, Eigen::Dynamic> weights = Eigen::Vector<T, Eigen::Dynamic>::Zero(n);}
\DoxyCodeLine{303             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < n; i++)\{}
\DoxyCodeLine{304                 weights[i] = gamma\_0*pow(eigenvecs.col(i).normalized()[0], 2);}
\DoxyCodeLine{305             \}}
\DoxyCodeLine{306 }
\DoxyCodeLine{307             \textcolor{comment}{// Preparing return type }}
\DoxyCodeLine{308             Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_affa69ff49dacba72e627338a63518874}{nw}} = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>::Zero(n, 2);}
\DoxyCodeLine{309 }
\DoxyCodeLine{310             \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_affa69ff49dacba72e627338a63518874}{nw}}.col(0) = \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad490796c3547284bf80d576edfdf24df}{nodes}};}
\DoxyCodeLine{311             \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_affa69ff49dacba72e627338a63518874}{nw}}.col(1) = weights;}
\DoxyCodeLine{312             }
\DoxyCodeLine{313             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_affa69ff49dacba72e627338a63518874}{nw}};}
\DoxyCodeLine{314         \}}
\DoxyCodeLine{315     \}; \textcolor{comment}{// GaussLogRule<T>}}
\DoxyCodeLine{316 }
\DoxyCodeLine{321     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{322     \textcolor{keyword}{class }\mbox{\hyperlink{class_g_q_log_1_1_gauss_pure_log_rule}{GaussPureLogRule}}: \textcolor{keyword}{public} \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule}{GaussLogRule}}<T>\{}
\DoxyCodeLine{323         \textcolor{keyword}{public}:}
\DoxyCodeLine{324 }
\DoxyCodeLine{325         \mbox{\hyperlink{class_g_q_log_1_1_gauss_pure_log_rule}{GaussPureLogRule}}(std::size\_t n) : \mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule}{GaussLogRule<T>}}(n) \{\};}
\DoxyCodeLine{326 }
\DoxyCodeLine{334         \textcolor{keyword}{template}<\textcolor{keyword}{typename} F>}
\DoxyCodeLine{335         T \mbox{\hyperlink{class_g_q_log_1_1_gauss_pure_log_rule_aac22d21c8866389baf20afd775636834}{operator()}}(F f) \{}
\DoxyCodeLine{336             T quad = 0;}
\DoxyCodeLine{337 }
\DoxyCodeLine{338             \textcolor{comment}{// evaluation of integral using regular Golub-\/Welsch}}
\DoxyCodeLine{339             \textcolor{keywordflow}{for}(std::size\_t i = 0; i < this-\/>degree; i++)\{}
\DoxyCodeLine{340                 \textcolor{comment}{// cast to real for cmath functions. Is only meant for f:R-\/>R anyways}}
\DoxyCodeLine{341                 quad -\/= (this-\/>weights[i] * std::real(f(this-\/>\mbox{\hyperlink{class_g_q_log_1_1_gauss_log_rule_ad490796c3547284bf80d576edfdf24df}{nodes}}[i]))) ; }
\DoxyCodeLine{342             \} }
\DoxyCodeLine{343             \textcolor{keywordflow}{return} quad;}
\DoxyCodeLine{344         \}}
\DoxyCodeLine{345     \}; \textcolor{comment}{// GaussPureLogRule}}
\DoxyCodeLine{346 }
\DoxyCodeLine{347 }
\DoxyCodeLine{348 \} \textcolor{comment}{// Namespace GQLog}}

\end{DoxyCode}
